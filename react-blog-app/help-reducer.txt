Application State is generated by reducers.

Reducers produce the value of our state.

{
    key_of_state:'Value_Of_State_By_Reducer'
}

After reducers returns value of our application we need to wire it up with our application.
So in index.js 
we binded it with our key : Reducer_Value

How to create our application state is being told by CombineReducers function. <- Important

In li we need to use key which will have unique value.


Connecting redux and react is done with a separate library react-redux


We are going to define a container.
Component is promoted to a container.

Container is also known as Smart Component.
Container has direct access to state produced by redux.

Most parent container which cares about the state should be promoted as a container.

App doesn't really care about list of book or active book. It cares about rendering book-list and
book-detail.

App should be a dumb Component
book-list and book-detail should be smart component.

when we forge a connection between react and redux that component becomes a container.

To connect react to redux we import connect {lowercase} from 'react-redux'

function mapStateToProps is used to set state to this.props

export default connect(mapStateToProps)(BookList)

connect takes a function, {functions} and a component and produces a container.

Whenever application state changes. Container will instantly re-render.
Object in state function will be asssigned as props to the component.

Actions and Action-Creators:

Used for changing state of an application.

An action creator is a function that returns an action.
Usually an object is returned from action creator which is sent to all the reducers.


All the actions generated flow through all the reducers automatically.

Depending on what action is generated we can return different application state which gets returned to
Component 

we usually setup a switch statement in a reducer.
E.g: If action type is book_selected.
we return action.book

Reducers doesnt have to react on every action.
In that case it returns the current state and no status change for that particular reducer

If it cares it will return new value which will be the new state.



The newly assembled state gets pumped back into all the diffrent containers.
And all the containers will run the function mapStateToProps.
And all the containers will re render the data


we have to make sure that action creator is wired up to redux.
so it passses through all the reducers.
we cannot directly call the function in the component.

bindActionCreators function is used to make sure that
action generated by action generator passes through reducers.


 return bindActionCreators({ selectBook : selectBook} , dispatch)

 dispatch keyword makes sure that all action creators pass through the reducers.

 Action Object will have a type and a payload.
 Type in uppercase.

State and action is passed to a reducer
State is not the application state - only the state this reducer is responsible for
same state actually comes back when an action occurs.

we must never return an undefined value from a reducer.
It gives an error.


When application boots up.
Under the hood it calls some actions.
So for the start we define a method which returns a default value.
E.g Loading and Select a book 


To make a controlled component we need to set our state whenever the input is changed.


In on event change method if you define a method outside render.
The context {this} will be something different.

In order to fix this we need to bind this keyword.

If you have a callback that has a reference to this then you need to bind it.

Whenever a child element of form like input is focused and we press enter.
Browser thinks that we are trying to submit the form.

We use form because when user sees input he tends to think that on pressing enter or
on submit there should happen something so if we use form element we dont need tobind this
event handlers it comes automatically.


Actions flow through the middleware in which they can be intercepted , modified or stopped
from going through reducers.


Middleware looks at the payload property from Action 
and we are attaching a promise as a payload so when we attach a promise as a payload.
In the reducer it will be resolved and we will have the data.

redux-promise ressolves the promise for us and gives us the data and so that will
wait untill it is resolved.

If action has a promise as a payload middleware will stop the action 
after promise resolves create a new action and send it to reducers.

We do not mutate the state in our reducer.
Instead we send a new instance of state.


... in ES6 means that it might be an array

retur


import { Sparklines } from 'react-sparklines';


ref attribute in react is used to reference to an html component rendered on the screen.

componentDidMount() method
Lifecycle method which is called automatically after element is rendered.

In this way we generally use third party libraries to work with react.

we never want to modify our state directly.

With react-router we get a package known as History which has the ability to
monitor browser's url and can update it.

History package sends the url to React-Router.
Purpose of react-router is that it updates the react components shown on the screen 
depending on the url and then passes it to react.

React receives component from react router


In our index.js file we replace <App> because what components are to be shown
in decided by react-router.
so we replaced it by <Router history={browserHistory} />

Router object decideds what components to render when url changes.

browserHistory tells react-router how to interpret changes to that url.

whenever url changes browserHistory monitors the url after the protocol.

http://www.blog.com/posts/5

whenever after .com changes browserHistory will  update it to react router.

There is an another library known as HashHistory 
http://www.blog.com/#posts/5

then we would care abour content after # in above url/

MemoryHistory  is also another library.


we need to tell react-router what valid routes our application have and the appropriate component to show 
for each routes.

Route object will be used for mapping betwwen route and component to show.

<Route path = "/" component={App} />

For path = / render component = App/


//4.0.0

Based on new url react-router instead of sending new HTML Request it renders new component

BrowserRouter interacts with History Library.

Route Object is used for the configuration like
if url is this than show this component.
if url is that then show that component. 

we need to import react-router-dom.
And import BrowserRouter and Route.

BrowserRouter should only have one child element so it is wrapped in a div

Route object has a a parmeter path and component and it is child of BrowserRouter.

In the div tag we can add any html or text along with Route.

    <BrowserRouter>
    <div>
      <Route path="/hello" component={Hello} />
      <Route path="/goodbye" component={Goodbye} />
    </div>
    </BrowserRouter>

    Note path has "/" 

    component name must not be same as the path.


In Route if we add path attribute a ":" it means a wild card.
It means anything like "/posts/:id"..
Here id can be anything   

<Route path="/posts/:id" component={PostsShow} />  

State can be an Array or an Object.

In Weather App we used Array but here we can use an object to show
the contents.

Usually we convert Array of Posts into an object.

This conversion from array to an object is the way in ehich production apps are made.

we will not use active Post selected because we can use url to have selected post

lodash utility _.mapKeys takes array as first parameter and a parameter from that array which will be the key

Props and state are related. The state of one component will often become the props of a child component.
	
For parent-child communication, simply pass props.

Use state to store the data your current page needs in your controller-view.

Use props to pass data & event handlers down to your child components.

These lists should help guide you when working with data in your components.

Props

are immutable
which lets React do fast reference checks
are used to pass data down from your view-controller
your top level component
have better performance
use this to pass data to child components


State

should be managed in your view-controller
your top level component
is mutable
has worse performance
should not be accessed from child components
pass it down with props instead


Instead of mapDispatchToProps we can directly use Action Creator in connect function.


When the task is that we only want to display in a component and do not want to
change the state we use mapStateToProps but when the task is that we want to change the
state by action creators we use mapDispatchToProps.

Arrow Function does not define this in new context.

If we use arrow function then no need to bind this keyword.

If using a normal function then we need to call it by.
this.funcName() and then bind it in constructor.

If we are calling function in a map then just define the function as this.FuncName.

React Lifecycle methods are called automatically.

React router matches path fuzilly.

It checks / first and so it will render index.
And so / and /posts/new both will render..

So to eliminate we use switch component.
So most specific route should be on top.

we add Link Component to route to another page.

<Link className="btn btn-primary" to="/posts/new">
                        Add a Post
</Link>

we should use Link tag instead of <a> tag because it prevents certain default behaviour 
like issuing an Http Request and generates certain event handlers.

Redux form is used to work with redux.

It helps us avoid using action Creators.


In redux form 
we identify different pieces of form state.

Make one field component per piece of state

user changes a 'Field' input

Redux form automatically handles changes -> Creators

User submits form

we validate inputs and handles form submittal


reduxForm is a function which allows us to communicate with form Reducer.

similar to connect Helper.

Field is used to specify an input.
Field knows how to interact with redux form
purpose of component is to return some JSX 
Component directly interacts with user


            <div>
                <input 
                    type="text"
                    {...field.input} //This is an object which contains diff event handlers and props like onchange value of input and all properies which will be communicated to input tag      
                />
            </div>

Attributes in Field can be accessed from field object.

For Redux Form we use
Field , reduxForm and reducer as formReducer

validate attribute in reduxForm is used for validation
validate function returns an object.
If object is empty than it means there is no error.

field.input is inbuilt

name in the Field and in errors.name in validation should be same.


when we wire reduxForm to our component it adds tons
of properties in our component
one of which is 
const { handleSubmit } = this.props


reduxForm is just responsible for handling the state and validation
of our form.

There are basically three field states

pristine - no input changed.
touched - focused on input and then moved outside
invalid state 


Destructuring is used to pull specific objects.

const { meta : { touched , error } } = field;

from field meta is pulled.
from meta touched and error is pulled.

To combine connect like helpers we 
add paranthesis arounf component name and in front of it use our helper function
Example:
export default reduxForm({
    validate,
    form:'PostsNewForm' //This string has to be unique
})(
    connect(null , {createPost})(PostsNew)
);

we want to wait for api request to complete and then redirect it to the 
main page.

we do not want user to click on submit and then it redirects to show page

we want that as soon as request is completed it should
automatically redirect known as programatic navigation

Like reduxForm reduxRouter also adds tons of props to
component it renders.

we can pass a callback to a action creator and after the request is 
completed we can use promise to call the callback function in then


Posts Show component 

User can manually enter the url for a specific post/show/id
and can also be redirected from index page so it should handle both the cases

return { ...state , [action.payload.data.id] : action.payload.data };

here an object of key id and value of payload.data will be appended.

To get the wildcard from the url react router provides us the props

this.props.match.param.id;

param lists all the wildcards and id is the name of wildcard.

in function mapStateToProps there is a second argument
known as ownProps which is identical to this.props

ownProps will be passed to the target component

so if we just want to return a particular piece of state and not the whole object
we can use that.

componentDidMount is called after render.

once you have destructured and got the property in {}

To refernce it again do not use {} again


For networking usage if we do not want to fetch data again
then we can always check that if props exist then do not fetch.

Example  
   componentDidMount(){
        if(!this.props.post){
        const { id } = this.props.match.params;
        console.log(id);
        this.props.fetchPost(id);
        }
    }


If there is a post already in the state and again if we add it.
It will be oberwritten <- Important.

we should use object to store our state level data

Redux thunk is used to deal with async action creators 
In redux thunk we return a function instead of object which was the case in vanilla redux.

Function takes dispatch as a parameter.


Component + Higher Order Component = Enhanced/Composed Component ( Additional functionality or data)


export default connect(mapStateToProps) will return something taking which we will call (App) Component

connect is made to communicate with our provider at the top of our application.
Provider wraps our Redux Store ( Object which holds our global application state ).

Provider monitors Redux Store.
If redux store updates that provider passes that state to child connect components.


***************Imp*************

If we are exporting a default component then in 
import statement it should not be in { }

Example
import reducers from './reducers';
import PostsIndex from './components/posts_index';
import PostsNew from './components/posts_new';
import PostsShow from './components/posts_show';

we need to import Link and other stuff from 'react-router-dom'


To render multiple components just wrap it in a div.

Composed Component is an instance of Higher Order Component.
{ ...this.props } will pass all the props of composed component.

In HOC we wrap the class with a function and we import that were we want to use HOC.


Context is similar to props but it is applicable to whole state tree.
props passs from parent to child componenet.

Context skips level and can get directly reference.

For getting access to this.context we need to define contextType first.
and the parameter in contextType will be accessible.

static contextTypes = {
    router: React.PropTypes.object
}

componentWillUpdate is called when new props are going to be handled.


Generally, if you refer to a method without () after it, such as onClick={this.handleClick}, you should bind that method.


With an arrow function, we have to pass it explicitly, but with bind any further arguments are automatically forwarded.

To fix it, use a second form of setState() that accepts a function rather than an object. That function will receive the previous state as the first argument, and the props at the time the update is applied as the second argument


... is known as spread operator


 If we send promise as a payload then nothing will happen on window
 nor something will show in console.

 To debug we can use the debugger keyword.

 In vanilla redux there is no wat we can handle asynchronus actions.
 so we use middleware.


 we can have many middlewares in one redux application

 actions pass through all the middleware.

 If middleware does not care about the action it is gpping to send to
 [Next] middleware

 If there are no further middlewares then send it to reducers.


 action creators are always called with dispatch so that they can flow through all 
 the reducers.

 action creators pass through middleware


 store = applyMiddleware(Async)(createStore)(reducers);

 Here Async is the middleware , if there are anyother middlewares 
 we can add them in first () if there are none then they will pass to reducers.

 Our custom middlewares have an argument of dispatch.
 which return a fn with Next
 which return a fn with action.
 
 export default function( { dispatch } ){
    return next => action => {
        console.log(action);

        next(action);
    };
}

Every action that got dispatched will pass through middlewares and then to reducers.

Our Async Middleware checks whether action has a promise.
If yes it waits until it resolves.
After it resolves we create a new action with same action type and send it to 
all the middlewares again but with data as a payload and not promise.


We need to make sure in middleware that we deal with only actions that 
we do care about else we just forward it to next middleware

like return next(action);

 dispatch(newAction);

 will run entire cycle again .
 dispatch means take this action and flow it to all the middlewares again.
 while next will mean that pass this action to next middleware in stack.

 Next time when the action again hits the middleware which dispatched it 
 It will encounter th earlier IF condition and in that condition we 
 will move to next(action).

 we should write middlewares in such a way that order of execution of middleware does not matter at all

 If we want to add middlewares more than one
 then in applyMiddleware() add middlewares by ,.
 Like applyMiddleware(m1,m2);

 In middleware you can check if the api response is coming from a particular endpoint and if that was
 we can mutate the response. Just an example.

 const newAction =  { ...action , payload: response };

 take whatever action is and just change the payload.
 Here payload will overwrite because it is an object.
 In array it appends.   

 Spread operator

 arr1 = [...arr1, ...arr2]; or
  arr1 = [...arr2, ...arr1];

It can be useful when our state is an array.

 concating both arrays.

 In case of object

 var obj1 = { foo: 'bar', x: 42 };
var obj2 = { foo: 'baz', y: 13 };

 var mergedObj = { ...obj1, ...obj2 };

 / Object { foo: "baz", x: 42, y: 13 }

To assign an array

var arr = [1, 2, 3];
var arr2 = [...arr]; // like arr.slice()
arr2.push(4)

var parts = ['shoulders', 'knees']; 
var lyrics = ['head', ...parts, 'and', 'toes']; 
// ["head", "shoulders", "knees", "and", "toes"]


Filter , map and Lodash should be used extensively.

Authentication

Client sends username / password.
Server sends an identifier if Authenticated.
For further requests cients sends that identifier also.

Cookie are associated with a particular domain.
A web server sends a cookie in the users browser.

That cookie is sent back with each request to identify that user.

Cookies are unique to each domain.
Cookies cannot be send to different domains.

We have to wire up token manually 
And can be sent to any domain.


In an app we can have multiple servers.
Content server -> Displays index.html + bundle.js <- No Auth Required.

API Server -> Interesting data -> here auth is required on other server.

By having multiple server.

One for API server. we can use load balancing and can be used by other sources
like web apps.



const server = http.createServer(app);
This line meand that if any http request comes to the server forward it to the app.
which is the instance of express.

morgan and bodyParse are middlewares in express framework

morgan is a logging framework.

bodyParser parses incoming request.
and parse it as a json.

Mongoose is an ORM to work with MongoDB.

Mongoose works with models.

In model we create a schema.
Schema is basically schema of databases

MongoDB is not case sensitive.

sudo service mongod start

req.body means anything in body request.


when we are workinh with the database itt takes x amount of time so generally there is a callback function 
associated with it.

while creating connection just pass lcalhost and then database name.


Salt + Plain Password  = Salt + Hashed Password in DB.

User ID + Our secret string = JSON Web token(JWT)

sub , iat is a property in jwt.
sub = subject
iat = issued at time.

passport is an authentication library and is used to check whether a user is authenticated.

bcrypt is used to encrypt password.

Incoming request -> passport -> Route

passport strategy1 -> verify user with startegy 1.

Strategy is a function to authenticate user.
There are many passport strategies.

Like for JWT , facebook , google

Strtegies are plugins of sort

There is no decryption in bcrypt.

salt + hashed pwd -> retrive salt.
Encrypt password -> Compare hashed pwd with hashed pwd by user

next is in mongoose and Middlewares.

done is in Passport.

Node - Javascript runtime used to execute code outside of browser.
Traditionally javascript used to run inside browser.

Express : Library that runs in the Node runtime.
It has helpers to make dealing with HTTP Traffic easier.

Server will be listening for Http Requests on a particular protocol

We will configure express to listen at particlar port.

Node will route Http Traffic to Express.

Common JS modules are used are used in server side.

app is used to configure route handlers will be associated with app object.

patch HTTp mathod is used to update some of the properties.
PUT updates whole

app -> Express app to register this route handler with.

We can have multiple apps but generally there is one.

we can send the JSON data back.

Express is telling node to listen to 5000 and send any requests to Express.

Deploy To Heroku.

Dynamic Port Binding:
Heroku will be hosting many applications in a server
so heroku will tell us from which port incoming request will be coming.

process.env.PORT whenever heroku runs our application it has the ability to inject environment
variables.

They are set in underlying runtime that node is running on top of.

Specify Node environment
To do that in package.json
add
  "engines":{
    "node":"8.1.1",
    "npm":"5.0.3"
  }

  It should be always in double quotes.


Specify a start script

In package.json in scripts enter 
start script  "start":"node index.js"
which willboot up our node server.


Heroku will install the dependencies
Do not upload node_modules  

so create .gitignore file

To install heroku cli
wget -qO- https://cli-assets.heroku.com/install-ubuntu.sh | sh

heroku login 
heroku create

There will be 2 links
1) will be the site on which we will visit
2) SECOND WILL  be our deployment link


create remote pository 

git remote add heroku https://git.heroku.com/agile-eyrie-52822.git

git push heroku master 

heroku open will open the website.


console.log() is same as process.stdout.write()

__filename refers to file we are currently in.

fs.createReadStream(__filename).pipe(process.stdout) will print the content of the file.

setTimeout(() => {

},100);

Node exits when it has no task to run.

setInterval(() =>{

},100);
iT WILL GET CALLED every 100 ms.


var a;

console.log(a) => undefined.

whenever we instantiate a variable and not give it a value.
Javascript initializes it with undefined.

typeOf(a) => undefined.

null is a special keyword that indicates absence of value.

undefined == null
null == undefined

This will evaluate to true.

null is an assignment value. It can be assigned to a variable as a representation of no value.

IIFE immediately invoked function expression
This is a javascipt function that runs as soon as it is defined.
Also known as self executing Anonymous function.
It consists of 2 major parts.
(function(){
    var a = 'nurul';
})

// Outside of the scope nurul is undefined and this method is used to prevent 
polluting the global namespace.

second part is invoking that function.

if that functio is assigned to a variable. It will store the return value 
rather than storing the function.

Syntax Parsers,
Execution Context,
Lexical environment.

Syntax Parsers : A program that reads your code and determines what it does and if its grammar is valid(grammar = syntax).

A program [compiler/parser] will convert our JS in to computer instructions     
something that computer can understand

when our instructions are being parsed it can do other extra stuff under the hood.

Lexical environment means where code is written and what surrounds it.
Where physically is that written.
It cares because syntax parser cares about it.

Execution Context:
A wrapper to help manage the code that is running.

Execution Context is the wrapper around your existing code; which contains code that you have not written; but is generated by the JS Engine.

There are lots of lexical environments. which one is currently running is managed via execution contexts.It can also contain things beyound what you have written in your code.

Object means collection of name/value pairs
value can have name/value.
E.g:
{

Address : 'classic',
Number : {
    Floor : 10,
    No : 9
}
}

In a execution context there should be only one value for a name.


Whenever you write javascript code it runs in a execution context.
A wrapper that the JS Engine -> The program that other people wrote parsing/looking/executing 
our code.
It wraps the current executing code in execution context.

The base execution context is the global execution context.

Global execution context creates an global object and creates a special variable this.

This two things are created for us by javascript.

Say in app.js there is no code.
But when it gets load inthe browser.
Syntax parser gets started it checks there is no code to run.
But Execution context was created.
so we can access this keyword.
and a global object.

In browser it is window.
In node it is process.

Global object is available to all the code running in that window in that js in that lexical envirionment.

and this sits in execution context.

At global level this = global object.


In jS Global means not inside a function.

when you create variables and functions
and you are not inside the function 
those variables and functions get attached to the global object.

A link to outer envirionment.
At global level outer environment is null.

execution context is also running our code.

Exeecution context is created in 2 phases.
Creation phase ->
where it creates global object , this , outer environment and
sets up memory space for variables and functions. which is known as hoisting.

Now functions are stored as a whole.
while variables are just declared and the value for which gets set in the seccond phase.
So in first phase it sets a placeholder of undefined.

All variables are initially set to undefined.
And function in entirety 

undefined means value has not be defined.

undefined is a keyword.

a is undefined is different than refrence error.


Reference error means it is not in memory.

var a;

now console.log(a) will be undefined.

but just console.log(a) will give refernce error because there is no variable a in memory because during hoisting there was no variable a.


Never set a = undefined.

Second phase is code execution.